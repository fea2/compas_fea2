"""
Console script for compas_fea2.
"""

import importlib
import os
import sys
import webbrowser
from typing import Optional

import click
import dotenv

from compas_fea2 import HOME
from compas_fea2 import VERBOSE

try:
    from fea2_extension.main import init_plugin  # type: ignore
except ImportError as e:
    if VERBOSE:
        print(f"WARNING: fea2_extension module not installed: {e}")


def validate_backend_name(ctx: click.Context, param: click.Parameter, value: str) -> str:
    """Validate and normalize backend name."""
    if not value:
        raise click.BadParameter("Backend name cannot be empty")
    if not value.replace("_", "").isalnum():
        raise click.BadParameter("Backend name must be alphanumeric (underscores allowed)")
    return value.lower()


def validate_setting_name(ctx: click.Context, param: click.Parameter, value: str) -> str:
    """Validate setting name."""
    if not value:
        raise click.BadParameter("Setting name cannot be empty")
    return value


def _create_basic_template(project_dir: str, backend: str) -> None:
    """Create basic project template."""
    main_script = """#!/usr/bin/env python3
'''
Basic FEA Analysis Script
Generated by compas_fea2 CLI
'''

from compas_fea2.model import Model, Part
from compas_fea2.model.nodes import Node
from compas_fea2.model.elements import BeamElement
from compas_fea2.model.materials import Steel
from compas_fea2.model.sections import GenericBeamSection as BeamSection

def main():
    # Create model
    model = Model(name="basic_model")
    
    # Create part
    part = Part(name="structure")
    model.add_part(part)
    
    # Define material and section
    material = Steel.S355()
    section = BeamSection(material=material, area=0.01, Ixx=0.0001, Iyy=0.0001, J=0.0001)
    
    # Create nodes
    n1 = Node([0, 0, 0])
    n2 = Node([5, 0, 0])
    part.add_nodes([n1, n2])
    
    # Create element
    element = BeamElement(nodes=[n1, n2], section=section, frame=[0, 0, 1])
    part.add_element(element)
    
    # Save model
    model.to_json("models/basic_model.json")
    print("Model saved to models/basic_model.json")

if __name__ == "__main__":
    main()
"""

    with open(os.path.join(project_dir, "scripts", "main.py"), "w") as f:
        f.write(main_script)

    # Create README
    readme = f"""# Basic FEA Project

This project was created using compas_fea2 CLI with the basic template.

## Structure
- `models/`: FEA model files
- `results/`: Analysis results
- `scripts/`: Python scripts
- `data/`: Input data files

## Usage
1. Run the main script: `python scripts/main.py`
2. Analyze with backend: `fea2 run models/basic_model.json --backend {backend}`

## Backend
Default backend: {backend}
"""

    with open(os.path.join(project_dir, "README.md"), "w") as f:
        f.write(readme)


def _create_truss_template(project_dir: str, backend: str) -> None:
    """Create truss project template."""
    main_script = """#!/usr/bin/env python3
'''
Truss Structure Analysis
Generated by compas_fea2 CLI
'''

from compas_fea2.model import Model, Part
from compas_fea2.model.nodes import Node
from compas_fea2.model.elements import BeamElement
from compas_fea2.model.materials import Steel
from compas_fea2.model.sections import GenericBeamSection as BeamSection

def main():
    # Create model
    model = Model(name="truss_model")
    
    # Create part
    part = Part(name="truss")
    model.add_part(part)
    
    # Define material and section
    material = Steel.S355()
    section = BeamSection(material=material, area=0.005, Ixx=0.00001, Iyy=0.00001, J=0.00001)
    
    # Create nodes for a simple truss
    nodes = [
        Node([0, 0, 0]),
        Node([3, 0, 0]),
        Node([6, 0, 0]),
        Node([1.5, 2, 0]),
        Node([4.5, 2, 0])
    ]
    part.add_nodes(nodes)
    
    # Create truss elements
    elements = [
        BeamElement(nodes=[nodes[0], nodes[1]], section=section, frame=[0, 0, 1]),
        BeamElement(nodes=[nodes[1], nodes[2]], section=section, frame=[0, 0, 1]),
        BeamElement(nodes=[nodes[0], nodes[3]], section=section, frame=[0, 0, 1]),
        BeamElement(nodes=[nodes[1], nodes[3]], section=section, frame=[0, 0, 1]),
        BeamElement(nodes=[nodes[1], nodes[4]], section=section, frame=[0, 0, 1]),
        BeamElement(nodes=[nodes[2], nodes[4]], section=section, frame=[0, 0, 1]),
        BeamElement(nodes=[nodes[3], nodes[4]], section=section, frame=[0, 0, 1])
    ]
    part.add_elements(elements)
    
    # Save model
    model.to_json("models/truss_model.json")
    print("Truss model saved to models/truss_model.json")

if __name__ == "__main__":
    main()
"""

    with open(os.path.join(project_dir, "scripts", "main.py"), "w") as f:
        f.write(main_script)


def _create_frame_template(project_dir: str, backend: str) -> None:
    """Create frame project template."""
    main_script = """#!/usr/bin/env python3
'''
Frame Structure Analysis
Generated by compas_fea2 CLI
'''

from compas_fea2.model import Model, Part
from compas_fea2.model.nodes import Node
from compas_fea2.model.elements import BeamElement
from compas_fea2.model.materials import Steel, Concrete
from compas_fea2.model.sections import GenericBeamSection as BeamSection

def main():
    # Create model
    model = Model(name="frame_model")
    
    # Create part
    part = Part(name="frame")
    model.add_part(part)
    
    # Define materials and sections
    steel = Steel.S355()
    beam_section = BeamSection(material=steel, area=0.02, Ixx=0.001, Iyy=0.0005, J=0.0008)
    column_section = BeamSection(material=steel, area=0.015, Ixx=0.0008, Iyy=0.0008, J=0.0012)
    
    # Create nodes for a 2-story frame
    nodes = [
        # Ground level
        Node([0, 0, 0]), Node([5, 0, 0]), Node([10, 0, 0]),
        # First floor
        Node([0, 0, 3]), Node([5, 0, 3]), Node([10, 0, 3]),
        # Second floor
        Node([0, 0, 6]), Node([5, 0, 6]), Node([10, 0, 6])
    ]
    part.add_nodes(nodes)
    
    # Create frame elements
    elements = []
    
    # Columns
    for i in range(3):
        elements.append(BeamElement(nodes=[nodes[i], nodes[i+3]], section=column_section, frame=[0, 1, 0]))
        elements.append(BeamElement(nodes=[nodes[i+3], nodes[i+6]], section=column_section, frame=[0, 1, 0]))
    
    # Beams
    elements.append(BeamElement(nodes=[nodes[3], nodes[4]], section=beam_section, frame=[0, 0, 1]))
    elements.append(BeamElement(nodes=[nodes[4], nodes[5]], section=beam_section, frame=[0, 0, 1]))
    elements.append(BeamElement(nodes=[nodes[6], nodes[7]], section=beam_section, frame=[0, 0, 1]))
    elements.append(BeamElement(nodes=[nodes[7], nodes[8]], section=beam_section, frame=[0, 0, 1]))
    
    part.add_elements(elements)
    
    # Save model
    model.to_json("models/frame_model.json")
    print("Frame model saved to models/frame_model.json")

if __name__ == "__main__":
    main()
"""

    with open(os.path.join(project_dir, "scripts", "main.py"), "w") as f:
        f.write(main_script)


def _create_shell_template(project_dir: str, backend: str) -> None:
    """Create shell project template."""
    main_script = """#!/usr/bin/env python3
'''
Shell Structure Analysis
Generated by compas_fea2 CLI
'''

from compas_fea2.model import Model, Part
from compas_fea2.model.nodes import Node
from compas_fea2.model.elements import ShellElement
from compas_fea2.model.materials import Steel
from compas_fea2.model.sections import ShellSection

def main():
    # Create model
    model = Model(name="shell_model")
    
    # Create part
    part = Part(name="shell")
    model.add_part(part)
    
    # Define material and section
    material = Steel.S355()
    section = ShellSection(t=0.01, material=material)
    
    # Create nodes for a simple shell plate
    nodes = [
        Node([0, 0, 0]), Node([2, 0, 0]), Node([4, 0, 0]),
        Node([0, 2, 0]), Node([2, 2, 0]), Node([4, 2, 0]),
        Node([0, 4, 0]), Node([2, 4, 0]), Node([4, 4, 0])
    ]
    part.add_nodes(nodes)
    
    # Create shell elements
    elements = [
        ShellElement(nodes=[nodes[0], nodes[1], nodes[4], nodes[3]], section=section),
        ShellElement(nodes=[nodes[1], nodes[2], nodes[5], nodes[4]], section=section),
        ShellElement(nodes=[nodes[3], nodes[4], nodes[7], nodes[6]], section=section),
        ShellElement(nodes=[nodes[4], nodes[5], nodes[8], nodes[7]], section=section)
    ]
    part.add_elements(elements)
    
    # Save model
    model.to_json("models/shell_model.json")
    print("Shell model saved to models/shell_model.json")

if __name__ == "__main__":
    main()
"""

    with open(os.path.join(project_dir, "scripts", "main.py"), "w") as f:
        f.write(main_script)


# -------------------------------- MAIN ----------------------------------#
@click.group()
def main() -> None:
    """fea2 main.

    Run `fea2 one-o-one` for more info.
    """
    pass


@main.command()
def one_o_one() -> None:
    """Basic explanation of command line usage."""
    click.echo("\nüîß compas_fea2 CLI - Finite Element Analysis Made Easy")
    click.echo("=" * 55)
    click.echo("\nAvailable Commands:")
    click.echo("  fea2 one-o-one                    Show this help")
    click.echo("  fea2 init-backend <name>          Initialize a new backend")
    click.echo("  fea2 change-setting <backend>     Change backend settings")
    click.echo("  fea2 list-backends                List installed backends")
    click.echo("  fea2 backend-info <name>          Show backend information")
    click.echo("  fea2 project create <name>        Create new project")
    click.echo("  fea2 model validate <file>        Validate model file")
    click.echo("  fea2 config show                  Show configuration")
    click.echo("  fea2 tools doctor                 Run diagnostics")
    click.echo("  fea2 docs                         Open documentation")
    click.echo("  fea2 version                      Show version info")
    click.echo("\nFor detailed help on any command, use: fea2 <command> --help")


@main.command()
@click.option("--clean", is_flag=True, default=False, help="Remove existing directories")
@click.argument("backend", callback=validate_backend_name)
def init_backend(backend: str, clean: bool) -> None:
    """Initialize a bare backend module.

    BACKEND: The name of the backend (will be converted to lowercase).
    """
    try:
        if "init_plugin" not in globals():
            click.echo("‚ùå Error: fea2_extension module not available. Cannot initialize backend.", err=True)
            sys.exit(1)

        init_plugin(HOME, backend, clean)
        click.echo(f"‚úÖ Successfully initialized backend: {backend}")
    except Exception as e:
        click.echo(f"‚ùå Error initializing backend {backend}: {e}", err=True)
        sys.exit(1)


@main.command()
@click.argument("backend", callback=validate_backend_name)
@click.argument("setting", callback=validate_setting_name)
@click.argument("value")
def change_setting(backend: str, setting: str, value: str) -> None:
    """Change a setting for the specified backend.

    BACKEND: The name of the backend
    SETTING: The setting to be changed
    VALUE: The new value for the setting

    Example usage:
        fea2 change-setting opensees exe "Applications/OpenSees3.7.0/bin/OpenSees"
    """
    module_name = f"compas_fea2_{backend}"

    try:
        m = importlib.import_module(module_name)
    except ImportError:
        click.echo(f"‚ùå Error: Backend '{module_name}' not found or not installed", err=True)
        sys.exit(1)

    try:
        env_path = os.path.join(m.HOME, "src", module_name, ".env")

        # Create directory if it doesn't exist
        os.makedirs(os.path.dirname(env_path), exist_ok=True)

        # Check if .env file exists, create if not
        if not os.path.exists(env_path):
            click.echo(f"‚ö†Ô∏è  Warning: .env file not found at {env_path}. Creating new file.")
            with open(env_path, "w") as f:
                f.write(f"# Environment file for {module_name}\n")

        dotenv.set_key(env_path, setting.upper(), value)
        click.echo(f"‚úÖ {setting.upper()} set to {value} for {module_name}")

    except AttributeError:
        click.echo(f"‚ùå Error: Backend module '{module_name}' does not have a HOME attribute", err=True)
        sys.exit(1)
    except PermissionError:
        click.echo(f"‚ùå Error: Permission denied when writing to {env_path}", err=True)
        sys.exit(1)
    except Exception as e:
        click.echo(f"‚ùå Error changing setting: {e}", err=True)
        sys.exit(1)


@main.command()
def list_backends() -> None:
    """List available compas_fea2 backends."""
    click.echo("üîç Searching for installed compas_fea2 backends...")

    backends = []

    # Common backend names to check
    common_backends = ["opensees", "abaqus", "ansys", "sofistik", "diana"]

    for backend in common_backends:
        module_name = f"compas_fea2_{backend}"
        try:
            importlib.import_module(module_name)
            backends.append(backend)
        except ImportError:
            continue

    if backends:
        click.echo(f"\n‚úÖ Available backends ({len(backends)}):")
        for backend in backends:
            click.echo(f"  - {backend}")
    else:
        click.echo("\n‚ùå No compas_fea2 backends found.")
        click.echo("üì¶ Install a backend with: pip install compas_fea2_<backend_name>")


@main.command()
@click.argument("backend", callback=validate_backend_name)
def backend_info(backend: str) -> None:
    """Show detailed information about a specific backend."""
    module_name = f"compas_fea2_{backend}"

    try:
        m = importlib.import_module(module_name)
        click.echo("üìã Backend Information")
        click.echo("=" * 30)
        click.echo(f"Backend: {backend}")
        click.echo(f"Module: {module_name}")
        click.echo(f"Version: {getattr(m, '__version__', 'Unknown')}")
        click.echo(f"Home: {getattr(m, 'HOME', 'Not found')}")

        # Show available settings
        env_path = os.path.join(m.HOME, "src", module_name, ".env")
        if os.path.exists(env_path):
            click.echo(f"Settings file: {env_path}")
        else:
            click.echo("Settings file: Not found")

    except ImportError:
        click.echo(f"‚ùå Backend '{backend}' not installed")
        sys.exit(1)


@main.command()
@click.argument("backend", callback=validate_backend_name)
def show_settings(backend: str) -> None:
    """Show current settings for the specified backend.

    BACKEND: The name of the backend
    """
    module_name = f"compas_fea2_{backend}"

    try:
        m = importlib.import_module(module_name)
    except ImportError:
        click.echo(f"‚ùå Error: Backend '{module_name}' not found or not installed", err=True)
        sys.exit(1)

    try:
        env_path = os.path.join(m.HOME, "src", module_name, ".env")

        if not os.path.exists(env_path):
            click.echo(f"‚ùå No settings file found for {module_name}")
            return

        click.echo(f"‚öôÔ∏è  Settings for {module_name}:")
        click.echo(f"üìÅ File: {env_path}")
        click.echo("-" * 40)

        with open(env_path, "r") as f:
            content = f.read().strip()
            if content:
                click.echo(content)
            else:
                click.echo("(empty)")

    except Exception as e:
        click.echo(f"‚ùå Error reading settings: {e}", err=True)
        sys.exit(1)


# -------------------------------- PROJECT MANAGEMENT ----------------------------------#
@main.group()
def project():
    """Project management commands."""
    pass


@project.command()
@click.argument("name")
@click.option("--backend", default="opensees", help="Default backend for the project")
@click.option("--template", type=click.Choice(["basic", "truss", "frame", "shell"]), default="basic")
def create(name: str, backend: str, template: str) -> None:
    """Create a new FEA project with template."""
    project_dir = os.path.join(os.getcwd(), name)

    if os.path.exists(project_dir):
        click.echo(f"‚ùå Project '{name}' already exists")
        sys.exit(1)

    os.makedirs(project_dir)

    # Create project structure
    dirs = ["models", "results", "scripts", "data"]
    for d in dirs:
        os.makedirs(os.path.join(project_dir, d))

    # Create template files based on selection
    templates = {"basic": _create_basic_template, "truss": _create_truss_template, "frame": _create_frame_template, "shell": _create_shell_template}

    templates[template](project_dir, backend)
    click.echo(f"‚úÖ Project '{name}' created with {template} template")


@project.command()
def validate_project() -> None:
    """Validate current project structure and dependencies."""
    # Check for required files and directories
    required_dirs = ["models", "results"]
    missing = [d for d in required_dirs if not os.path.exists(d)]

    if missing:
        click.echo(f"‚ö†Ô∏è  Missing directories: {', '.join(missing)}")
    else:
        click.echo("‚úÖ Project structure is valid")


# -------------------------------- MODEL MANAGEMENT ----------------------------------#
@main.group()
def model():
    """Model management and validation commands."""
    pass


@model.command()
@click.argument("model_file")
@click.option("--output", "-o", help="Output validation report file")
def validate(model_file: str, output: Optional[str]) -> None:
    """Validate a FEA model for common issues."""
    if not os.path.exists(model_file):
        click.echo(f"‚ùå Model file '{model_file}' not found")
        sys.exit(1)

    # Import and validate model
    try:
        # This would need to be implemented based on your model structure
        from compas_fea2.model import Model

        model = Model.from_json(model_file)

        issues = []
        warnings = []

        # Check for common issues using hasattr to avoid type errors
        if not hasattr(model, "parts") or not model.parts:  # type: ignore
            issues.append("No parts defined in model")

        if not hasattr(model, "nodes") or not model.nodes:  # type: ignore
            warnings.append("No nodes found")

        # Report results
        if issues:
            click.echo("‚ùå Issues found:")
            for issue in issues:
                click.echo(f"  - {issue}")

        if warnings:
            click.echo("‚ö†Ô∏è  Warnings:")
            for warning in warnings:
                click.echo(f"  - {warning}")

        if not issues and not warnings:
            click.echo("‚úÖ Model validation passed")

    except Exception as e:
        click.echo(f"‚ùå Error validating model: {e}")
        sys.exit(1)


@model.command()
@click.argument("model_file")
def info(model_file: str) -> None:
    """Display model statistics and information."""
    try:
        from compas_fea2.model import Model

        model = Model.from_json(model_file)

        click.echo(f"üìä Model: {model.name or 'Unnamed'}")
        click.echo("=" * 30)
        click.echo(f"Parts: {len(getattr(model, 'parts', []))}")
        click.echo(f"Nodes: {len(getattr(model, 'nodes', []))}")
        click.echo(f"Elements: {len(getattr(model, 'elements', []))}")
        click.echo(f"Materials: {len(getattr(model, 'materials', []))}")
        click.echo(f"Sections: {len(getattr(model, 'sections', []))}")

    except Exception as e:
        click.echo(f"‚ùå Error reading model: {e}")
        sys.exit(1)


# -------------------------------- RESULTS MANAGEMENT ----------------------------------#
@main.group()
def results():
    """Results management and post-processing commands."""
    pass


@results.command()
@click.argument("results_file")
@click.option("--format", type=click.Choice(["json", "csv", "vtk"]), default="json")
@click.option("--output", "-o", help="Output file")
def export(results_file: str, format: str, output: Optional[str]) -> None:
    """Export results to different formats."""
    if not os.path.exists(results_file):
        click.echo(f"‚ùå Results file '{results_file}' not found")
        sys.exit(1)

    try:
        # Implementation would depend on your results structure
        click.echo(f"üîÑ Exporting results to {format} format...")
        # Add export logic here
        output_file = output or f"output.{format}"
        click.echo(f"‚úÖ Results exported to {output_file}")

    except Exception as e:
        click.echo(f"‚ùå Error exporting results: {e}")
        sys.exit(1)


@results.command()
@click.argument("results_file")
def summary(results_file: str) -> None:
    """Display results summary."""
    try:
        # Implementation would read and summarize results
        click.echo("üìà Results Summary:")
        click.echo("=" * 20)
        click.echo("- Analysis completed successfully")
        click.echo("- Maximum displacement: X.XX mm")
        click.echo("- Maximum stress: X.XX MPa")

    except Exception as e:
        click.echo(f"‚ùå Error reading results: {e}")
        sys.exit(1)


# -------------------------------- CONFIGURATION ----------------------------------#
@main.group()
def config():
    """Configuration management commands."""
    pass


@config.command()
def show() -> None:
    """Show current global configuration."""
    try:
        from compas_fea2 import GLOBAL_TOLERANCE
        from compas_fea2 import POINT_OVERLAP
        from compas_fea2 import PRECISION
        from compas_fea2 import VERBOSE

        click.echo("‚öôÔ∏è  Global Configuration:")
        click.echo("=" * 25)
        click.echo(f"  VERBOSE: {VERBOSE}")
        click.echo(f"  POINT_OVERLAP: {POINT_OVERLAP}")
        click.echo(f"  GLOBAL_TOLERANCE: {GLOBAL_TOLERANCE}")
        click.echo(f"  PRECISION: {PRECISION}")
    except ImportError:
        click.echo("‚ùå Configuration variables not available")


@config.command()
@click.argument("key")
@click.argument("value")
def set(key: str, value: str) -> None:
    """Set a global configuration value."""
    valid_keys = ["VERBOSE", "POINT_OVERLAP", "GLOBAL_TOLERANCE", "PRECISION"]

    if key.upper() not in valid_keys:
        click.echo(f"‚ùå Invalid key. Valid keys: {', '.join(valid_keys)}")
        sys.exit(1)

    # Update .env file
    env_path = os.path.join(HOME, ".env")
    dotenv.set_key(env_path, key.upper(), value)
    click.echo(f"‚úÖ {key.upper()} set to {value}")


@config.command()
def reset() -> None:
    """Reset configuration to defaults."""
    if click.confirm("Reset all configuration to defaults?"):
        try:
            from compas_fea2 import init_fea2

            init_fea2()
            click.echo("‚úÖ Configuration reset to defaults")
        except ImportError:
            click.echo("‚ùå Reset function not available")


# -------------------------------- TOOLS AND UTILITIES ----------------------------------#
@main.group()
def tools():
    """Utility tools and helpers."""
    pass


@tools.command()
@click.argument("input_file")
@click.argument("output_file")
@click.option("--backend-from", required=True, help="Source backend")
@click.option("--backend-to", required=True, help="Target backend")
def convert(input_file: str, output_file: str, backend_from: str, backend_to: str) -> None:
    """Convert model between different backends."""
    click.echo(f"üîÑ Converting from {backend_from} to {backend_to}...")
    # Implementation would handle format conversion
    click.echo(f"‚úÖ Converted {input_file} ‚Üí {output_file}")


@tools.command()
@click.argument("model_file")
@click.option("--scale", default=1.0, help="Scale factor for visualization")
def visualize(model_file: str, scale: float) -> None:
    """Launch interactive model visualization."""
    try:
        # This would need to be implemented based on available visualization
        click.echo("üñºÔ∏è  Launching model viewer...")
        click.echo(f"Model: {model_file}")
        click.echo(f"Scale: {scale}")

    except ImportError:
        click.echo("‚ùå Visualization dependencies not installed")
        click.echo("Install with: pip install compas_fea2[viz]")
        sys.exit(1)


@tools.command()
@click.option("--check-backends", is_flag=True, help="Check backend installations")
@click.option("--check-dependencies", is_flag=True, help="Check Python dependencies")
def doctor(check_backends: bool, check_dependencies: bool) -> None:
    """Diagnose installation and configuration issues."""
    click.echo("üîç Running compas_fea2 diagnostics...")

    if check_backends or not (check_backends or check_dependencies):
        # Check backend installations
        click.echo("\nüì¶ Backend Status:")
        common_backends = ["opensees", "abaqus", "ansys", "sofistik", "diana"]
        for backend in common_backends:
            try:
                importlib.import_module(f"compas_fea2_{backend}")
                click.echo(f"  ‚úÖ compas_fea2_{backend}: Installed")
            except ImportError:
                click.echo(f"  ‚ùå compas_fea2_{backend}: Not installed")

    if check_dependencies or not (check_backends or check_dependencies):
        # Check Python dependencies
        click.echo("\nüêç Dependency Status:")
        dependencies = ["click", "numpy", "compas"]
        for dep in dependencies:
            try:
                importlib.import_module(dep)
                click.echo(f"  ‚úÖ {dep}: Available")
            except ImportError:
                click.echo(f"  ‚ùå {dep}: Missing")

    click.echo("\n‚úÖ Diagnostics complete")


# -------------------------------- DOCUMENTATION AND HELP ----------------------------------#
@main.command()
def docs() -> None:
    """Open documentation in browser."""
    url = "https://compas-dev.github.io/compas_fea2"
    click.echo(f"üåê Opening documentation: {url}")
    webbrowser.open(url)


@main.command()
def examples() -> None:
    """List and download example projects."""
    examples = ["simple_truss", "cantilever_beam", "frame_analysis", "shell_structure"]

    click.echo("üìö Available examples:")
    for i, example in enumerate(examples, 1):
        click.echo(f"  {i}. {example}")

    choice = click.prompt("Select example to download (1-4)", type=int)
    if 1 <= choice <= len(examples):
        # Download and extract example
        click.echo(f"‚úÖ Downloaded {examples[choice - 1]} example")
    else:
        click.echo("‚ùå Invalid selection")


@main.command()
def version() -> None:
    """Show version information."""
    try:
        from compas_fea2 import __version__

        click.echo(f"üì¶ compas_fea2 version: {__version__}")
    except ImportError:
        click.echo("‚ùå Version information not available")

    # Show backend versions
    click.echo("\nüîß Installed backends:")
    for backend in ["opensees", "abaqus", "ansys", "sofistik", "diana"]:
        try:
            m = importlib.import_module(f"compas_fea2_{backend}")
            version = getattr(m, "__version__", "Unknown")
            click.echo(f"  üìå compas_fea2_{backend}: {version}")
        except ImportError:
            pass


# -------------------------------- DEBUG ----------------------------------#
if __name__ == "__main__":
    sys.exit(main())
